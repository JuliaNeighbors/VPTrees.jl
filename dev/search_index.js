var documenterSearchIndex = {"docs":
[{"location":"#VPTrees.jl-1","page":"Home","title":"VPTrees.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Implementation of Vantage Point Trees in Julia.  A Vantage Point Tree is a metric tree which can be used for nearest neighbor or radius searches in any metric space. See Data structures and algorithms for nearest neighbor search in general metric spaces.","category":"page"},{"location":"#Example:-1","page":"Home","title":"Example:","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using VPTrees\nusing StringDistances\n\ndata = [\"bla\", \"blub\", \"asdf\", \":assd\", \"ast\", \"baube\"]\nvptree = VPTree(data, Levenshtein()))\nquery = \"blau\"\nradius = 2\ndata[find(vptree, query, radius)]\n# 2-element Array{String,1}:\n#  \"bla\" \n#  \"blub\"\nn_neighbors = 3\ndata[find_nearest(vptree, query, n_neighbors)]\n# 3-element Array{String,1}:\n#  \"baube\"\n#  \"blub\" \n#  \"bla\"","category":"page"},{"location":"#Related-Packages-1","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The following packages implement other data structures for use in nearest neighbor and radius search in metric space:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"BKTrees.jl\nNearestNeighbors.jl implementing Ball Trees","category":"page"},{"location":"#API-1","page":"Home","title":"API","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [VPTrees]","category":"page"},{"location":"#VPTrees.VPTree","page":"Home","title":"VPTrees.VPTree","text":"VPTree(data::Vector{InputType}, metric; threaded=nothing)\n\nConstruct Vantage Point Tree with a vector of data and given a callable metric.  threaded uses threading is only avaible in Julia 1.3+ to parallelize construction of the Tree. When not explicitly set, is set to true when the necessary conditions are met.\n\nExample:\n\nusing VPTrees\nusing StringDistances\n\ndata = [\"bla\", \"blub\", \"asdf\", \":assd\", \"ast\", \"baube\"]\nvptree = VPTree(data, Levenshtein())\nquery = \"blau\"\nradius = 2\ndata[find(vptree, query, radius)]\n# 2-element Array{String,1}:\n#  \"bla\" \n#  \"blub\"\nn_neighbors = 3\ndata[find_nearest(vptree, query, n_neighbors)]\n# 3-element Array{String,1}:\n#  \"baube\"\n#  \"blub\" \n#  \"bla\"\n\n\n\n\n\n","category":"type"},{"location":"#VPTrees.find-Union{Tuple{MetricReturnType}, Tuple{InputType}, Tuple{VPTree{InputType,MetricReturnType},InputType,MetricReturnType}, Tuple{VPTree{InputType,MetricReturnType},InputType,MetricReturnType,Any}} where MetricReturnType where InputType","page":"Home","title":"VPTrees.find","text":"find(vptree::VPTree{InputType, MetricReturnType}, query::InputType, radius::MetricReturnType, skip=nothing)::Vector{Int}\n\nFind all items in vptree within radius of query with respect to the metric defined in the VPTree. Returns indices into VPTree.data. The optional skip argument is a function f(::Int)::Bool which can be used to omit points in the tree from the search based on their index.\n\nExample\n\nusing VPTrees\nusing StringDistances\n\ndata = [\"bla\", \"blub\", \"asdf\", \":assd\", \"ast\", \"baube\"]\nmetric = (a, b) -> evaluate(Levenshtein(),a,b)\nvptree = VPTree(data, metric)\nquery = \"blau\"\nradius = 2\ndata[find(vptree, query, radius)]\n# 2-element Array{String,1}:\n#  \"bla\" \n#  \"blub\"\n\n\n\n\n\n","category":"method"},{"location":"#VPTrees.find_nearest-Union{Tuple{MetricReturnType}, Tuple{InputType}, Tuple{VPTree{InputType,MetricReturnType},InputType,Int64}, Tuple{VPTree{InputType,MetricReturnType},InputType,Int64,Any}} where MetricReturnType where InputType","page":"Home","title":"VPTrees.find_nearest","text":"find_nearest(vptree::VPTree{InputType, MetricReturnType}, query::InputType, n_neighbors::Int, skip=nothing)::Vector{Int}\n\nFind n_neighbors items in vptree closest to query with respect to the metric defined in the VPTree. Returns indices into VPTree.data. The optional skip argument is a function f(::Int)::Bool which can be used to omit points in the tree from the search based on their index.\n\nExample:\n\nusing VPTrees\nusing StringDistances\n\ndata = [\"bla\", \"blub\", \"asdf\", \":assd\", \"ast\", \"baube\"]\nmetric = (a, b) -> evaluate(Levenshtein(),a,b)\nvptree = VPTree(data, metric)\nquery = \"blau\"\nn_neighbors = 3\ndata[find_nearest(vptree, query, n_neighbors)]\n# 3-element Array{String,1}:\n#  \"baube\"\n#  \"blub\"\n#  \"bla\"\n\n\n\n\n\n","category":"method"}]
}
